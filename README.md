# Complexity Validation: Dense Factorizations & Solvers (Square/Tall/Wide)

A tiny, reproducible benchmark to **empirically validate complexity scaling**
for classic dense linearâ€algebra routines under different matrix shapes:

- **Square**: LU solve, Cholesky solve (SPD), QR (Householder), economy SVD  
- **Tall/Wide**: QR, economy SVD, least squares (`lstsq`), pseudoinverse (`pinv`), **randomized truncated SVD(k)**

It fits runtime to a power law **t â‰ˆ a Â· n^p** and plots logâ€“log curves to show
the **expected slope â‰ˆ 3** for classical dense algorithms, with **SVD having a larger constant**.

> If you use a task dimension model like `n = c Â· M` (with `M = 6 + mÂ·a`),
> you can directly map the fitted exponent/results to your problem size.

---

## ğŸ”§ Installation

- Python â‰¥ 3.9
- Only 3 dependencies:
  ```bash
  pip install -r requirements.txt

## ğŸ“Š Example Results

Below are sample plots generated by the benchmark (from `results/`):

### Square Matrices
- **LU vs Cholesky**
![LU vs Cholesky](plot_lu_chol.png)

- **SVD vs QR**
![SVD vs QR](plot_svd_qr.png)

### Tall Matrices (Ï = 1.5, 2.0)
- **Ï = 1.5**
![Tall rho=1.5](plot_tall_rho1p5_methods.png)

- **Ï = 2.0**
![Tall rho=2.0](plot_tall_rho2p0_methods.png)

### Wide Matrices (Ï = 0.5)
- **Ï = 0.5**
![Wide rho=0.5](plot_wide_rho0p5_methods.png)